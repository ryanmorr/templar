{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/attr-binding.js","src/binding.js","src/event-binding.js","src/event-emitter.js","src/index.js","src/node-binding.js","src/parser.js","src/templar.js","src/util.js"],"names":["f","exports","module","define","amd","window","global","self","this","templar","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_binding","_parser","_util","AttrBinding","tpl","node","attr","text","_this","_classCallCheck","_possibleConstructorReturn","_getPrototypeOf","value","default","_get","prototype","oldValue","interpolate","data","trim","updateAttribute","events","emit","Binding","tokens","every","token","renderer","render","bind","scheduleRender","EventBinding","type","removeAttribute","removeEventListener","isFunction","addEventListener","EventEmitter","hashmap","name","callback","callbacks","undefined","push","len","splice","_len","arguments","args","Array","_key","forEach","apply","_templar","_interopRequireDefault","NodeBinding","nodes","unmount","parent","parentNode","removeChild","getParent","index","getNodeIndex","children","childNodes","purge","frag","interpolateDOM","root","nodeType","insertBefore","appendChild","replace","matcherRe","all","getTokenValue","fn","document","createDocumentFragment","getMatches","nodeContentRe","matches","_escape","substr","_typeof","isHTML","parseHTML","createTextNode","escapeHTML","mount","nodeName","parseTemplate","bindings","from","reduce","hasInterpolation","binding","_nodeBinding","addBindings","attributes","_eventBinding","slice","toLowerCase","_attrBinding","hasChildNodes","simpleIdentifierRe","expressionsRe","identifierRe","rootRe","exprCache","str","indexOf","match","setTokens","test","expr","body","concat","vars","map","join","Function","compileExpression","_eventEmitter","Templar","id","uid","wrapFragment","mounted","set","isMounted","getTemplateNodes","getRoot","_this2","method","contains","shouldUpdate","Object","keys","_this3","on","remove","selector","querySelectorAll","create","re","lastIndex","exec","obj","toString","htmlRe","escapeHTMLRe","escapeHTMLMap","html","supportsTemplate","template","createElement","innerHTML","importNode","content","div","firstChild","Math","floor","counter","random","substring","nextSibling","first","last","elements","isTpl","className","style","cssText","tag","tagName","setAttribute","frame","requestAnimationFrame","batch","<",">","&","\"","'","pop"],"mappings":";CAAA,SAAAA,GAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,QAAAT,KAAA,CAAA,WAAA,OAAA,SAAAU,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAf,GAAA,IAAAY,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAjB,GAAAgB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,IAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,KAAA,MAAAI,EAAAE,KAAA,mBAAAF,EAAA,IAAAG,EAAAV,EAAAG,GAAA,CAAAd,QAAA,IAAAU,EAAAI,GAAA,GAAAQ,KAAAD,EAAArB,QAAA,SAAAS,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAY,EAAAA,EAAArB,QAAAS,EAAAC,EAAAC,EAAAC,GAAA,OAAAD,EAAAG,GAAAd,QAAA,IAAA,IAAAiB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,EAAA,CAAA,CAAAW,EAAA,CAAA,SAAAR,EAAAf,EAAAD,kFCGA,MAAAyB,KAAAT,EAAA,0CACAU,EAAAV,EAAA,YACAW,EAAAX,EAAA,4lCASqBY,cAWjB,SAAAA,EAAYC,EAAKC,EAAMC,EAAMC,GAAM,IAAAC,EAAA,mGAAAC,CAAA3B,KAAAqB,IAC/BK,EAAAE,EAAA5B,KAAA6B,EAAAR,GAAAN,KAAAf,KAAMsB,EAAKG,KACNF,KAAOA,EACZG,EAAKF,KAAOA,EACZE,EAAKI,MAAQ,KAJkBJ,wPAXER,EAAAa,gDAyBjCC,EAAAH,EAAAR,EAAAY,WAAA,SAAAjC,MAAAe,KAAAf,MACA,IAAMkC,EAAWlC,KAAK8B,MACtB9B,KAAK8B,OAAQ,EAAAX,EAAAgB,aAAYnC,KAAKyB,KAAMzB,KAAKsB,IAAIc,MAAMC,QACnD,EAAAjB,EAAAkB,iBAAgBtC,KAAKuB,KAAMvB,KAAKwB,KAAMxB,KAAK8B,OAC3C9B,KAAKsB,IAAIiB,OAAOC,KAAK,kBAAmBxC,KAAKuB,KAAMW,EAAUlC,KAAK8B,wNCxC1E,IAAAV,EAAAX,EAAA,oLASqBgC,aASjB,SAAAA,EAAYnB,EAAKG,gGAAME,CAAA3B,KAAAyC,GACnBzC,KAAKsB,IAAMA,EACXtB,KAAKyB,KAAOA,2DAUNiB,GACN1C,KAAK0C,OAASA,yCAWH,IAAAhB,EAAA1B,KACX,OAAOA,KAAK0C,OAAOC,MAAM,SAACC,GAAD,OAAWA,KAASlB,EAAKJ,IAAIc,wCAUjDpC,KAAK6C,WACN7C,KAAK6C,SAAW7C,KAAK8C,OAAOC,KAAK/C,OACjC,EAAAoB,EAAA4B,gBAAehD,KAAK6C,4CAWxB7C,KAAK6C,SAAW,2LClExB,MAAA3B,KAAAT,EAAA,0CACAW,EAAAX,EAAA,4lCASqBwC,cAWjB,SAAAA,EAAY3B,EAAKC,EAAM2B,EAAMpB,GAAO,IAAAJ,EAAA,mGAAAC,CAAA3B,KAAAiD,IAChCvB,EAAAE,EAAA5B,KAAA6B,EAAAoB,GAAAlC,KAAAf,KAAMsB,EAAKQ,KACNP,KAAOA,EACZG,EAAKwB,KAAOA,EACZxB,EAAKH,KAAK,KAAO2B,GAAQ,KACzBxB,EAAKH,KAAK4B,gBAAgB,KAAOD,GACjCxB,EAAKI,MAAQ,KANmBJ,wPAXER,EAAAa,gDA0BlCC,EAAAH,EAAAoB,EAAAhB,WAAA,SAAAjC,MAAAe,KAAAf,MACA,IAAMkC,EAAWlC,KAAK8B,MAChBA,EAAQ9B,KAAKsB,IAAIc,KAAKpC,KAAK0C,OAAO,IACpCZ,IAAU9B,KAAK8B,QAGf9B,KAAK8B,QACL9B,KAAKuB,KAAK6B,oBAAoBpD,KAAKkD,KAAMlD,KAAK8B,OAC9C9B,KAAK8B,MAAQ,OAEb,EAAAV,EAAAiC,YAAWvB,KACX9B,KAAKuB,KAAK+B,iBAAiBtD,KAAKkD,KAAMpB,GACtC9B,KAAK8B,MAAQA,EACb9B,KAAKsB,IAAIiB,OAAOC,KAAK,kBAAmBxC,KAAKuB,KAAMW,EAAUlC,KAAK8B,6MCjD9E,IAAAV,EAAAX,EAAA,oLAQqB8C,aAOjB,SAAAA,iGAAc5B,CAAA3B,KAAAuD,GACVvD,KAAKuC,QAAS,EAAAnB,EAAAoC,6DAUfC,EAAMC,GACL,IAAIC,EAAY3D,KAAKuC,OAAOkB,QACVG,IAAdD,IACAA,EAAY,GACZ3D,KAAKuC,OAAOkB,GAAQE,GAExBA,EAAUE,KAAKH,kCAUZD,EAAMC,GACT,IAAMC,EAAY3D,KAAKuC,OAAOkB,GAC9B,QAAkBG,IAAdD,EACA,IAAK,IAAIpD,EAAI,EAAGuD,EAAMH,EAAU3C,OAAQT,EAAIuD,EAAKvD,IAC7C,GAAIoD,EAAUpD,KAAOmD,EAEjB,YADAC,EAAUI,OAAOxD,EAAG,gCAe/BkD,GAAe,IAAA,IAAAO,EAAAC,UAAAjD,OAANkD,EAAM,IAAAC,MAAA,EAAAH,EAAAA,EAAA,EAAA,GAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAANF,EAAME,EAAA,GAAAH,UAAAG,GAChB,IAAMT,EAAY3D,KAAKuC,OAAOkB,QACZG,IAAdD,GAA2BA,EAAU3C,QACrC2C,EAAUU,QAAQ,SAACX,GAAD,OAAcA,EAAQY,WAAR,EAAYJ,oLCtDzC,SAAiB5C,EAAKc,GACjC,OAAO,IAAImC,EAAAxC,QAAQT,EAAKc,IAZ5B,MAAAmC,KAAA9D,EAAA,kLCAA,IAAA8D,EAAAC,EAAA/D,EAAA,cACAS,EAAAsD,EAAA/D,EAAA,cACAU,EAAAV,EAAA,YACAW,EAAAX,EAAA,+oCASqBgE,cASjB,SAAAA,EAAYnD,EAAKC,GAAM,IAAAG,EAAA,mGAAAC,CAAA3B,KAAAyE,IACnB/C,EAAAE,EAAA5B,KAAA6B,EAAA4C,GAAA1D,KAAAf,KAAMsB,EAAKC,EAAKa,QACXsC,MAAQ,CAACnD,GAFKG,wPATcR,EAAAa,+CAqBjC/B,KAAK0E,MAAML,QAAQ,SAAC9C,GAChB,GAAIA,aAAgBgD,EAAAxC,QAChBR,EAAKoD,cADT,CAIA,IAAMC,EAASrD,EAAKsD,WAChBD,GACAA,EAAOE,YAAYvD,uCAY3BS,EAAAH,EAAA4C,EAAAxC,WAAA,SAAAjC,MAAAe,KAAAf,MACA,IAAM0E,EAAQ,GACRnD,EAAOvB,KAAK0E,MAAM,GAClBE,GAAS,EAAAxD,EAAA2D,WAAUxD,GACnByD,GAAQ,EAAA5D,EAAA6D,cAAaL,EAAQrD,GAC7B2D,EAAWN,EAAOO,WACxBnF,KAAKoF,QACL,IAAMC,GAAO,EAAAlE,EAAAmE,gBAAetF,KAAKyB,KAAMzB,KAAKsB,IAAIc,KAAM,SAACN,GAC/CA,aAAiByC,EAAAxC,UACjBD,EAAMyD,KAAOX,GAEE,KAAnB9C,EAAM0D,SAAkBd,EAAMb,KAAKS,MAAMI,EAAO5C,EAAMqD,YAAcT,EAAMb,KAAK/B,KAEnF9B,KAAK0E,MAAQA,EACbM,KAASE,EAAWN,EAAOa,aAAaJ,EAAMH,EAASF,IAAUJ,EAAOc,YAAYL,GACpFrF,KAAKsB,IAAIiB,OAAOC,KAAK,SAAUoC,+NC8ChC,SAAqBtD,EAAKc,GAC7B,OAAOd,EAAIqE,QAAQC,EAAW,SAACC,EAAKjD,GAAN,OAAgBkD,EAAclD,EAAOR,uBAchE,SAAwBd,EAAKc,EAAM2D,GACtC,IAAMV,EAAOW,SAASC,yBAoCtB,OAnCA,EAAA7E,EAAA8E,YAAWC,EAAe7E,EAAK,SAAC8E,GAC5B,IAAItE,EACJ,GAAkB,MAAdsE,EAAQ,GAAY,CACpB,IAAIxD,EAAQwD,EAAQ,GAAIC,GAAS,EAMjC,OALiB,MAAbzD,EAAM,KACNyD,GAAS,EACTzD,EAAQA,EAAM0D,OAAO,IAGzBC,EADAzE,EAAQgE,EAAclD,EAAOR,KAEzB,IAAK,SACD,IAAKiE,IAAU,EAAAjF,EAAAoF,QAAO1E,GAAQ,CAC1BA,GAAQ,EAAAV,EAAAqF,WAAU3E,GAClB,MAGR,IAAK,SACL,IAAK,UACDA,EAAQkE,SAASU,gBAAe,EAAAtF,EAAAuF,YAAW7E,IAC3C,MACJ,QACQA,aAAiByC,EAAAxC,SACjBD,EAAM8E,MAAMvB,SAGH,MAAde,EAAQ,KACftE,EAAQkE,SAASU,eAAeN,EAAQ,KAE/B,MAATtE,IACAiE,EAAGjE,GACCA,EAAM+E,UACNxB,EAAKK,YAAY5D,MAItBuD,mBAiBJ,SAASyB,EAAcxF,EAAKoD,GAA6B,IAAtBqC,EAAsB,EAAA9C,UAAAjD,aAAA4C,IAAAK,UAAA,GAAAA,UAAA,IAAX,EAAA7C,EAAAoC,WACjD,OAAOW,MAAM6C,KAAKtC,GAAOuC,OAAO,SAACF,EAAUxF,GACvC,GAAsB,IAAlBA,EAAKiE,UACL,GAAI0B,EAAiB3F,EAAKa,MAAO,CAC7B,IAAM+E,EAAU,IAAIC,EAAArF,QAAYT,EAAKC,GACrC8F,EAAYN,EAAUxF,EAAKa,KAAM+E,SAElC,GAAsB,IAAlB5F,EAAKiE,SAAgB,CAC5B,IAAK,IAAIjF,EAAI,EAAGS,EAASO,EAAK+F,WAAWtG,OAAQT,EAAIS,EAAQT,IAAK,CAC9D,IAAMiB,EAAOD,EAAK+F,WAAW/G,GAAIkD,EAAOjC,EAAKiC,KAAM3B,EAAQN,EAAKM,MAChE,GAAIoF,EAAiBpF,GAAQ,CACzB,IAAMZ,EAAuB,MAAZuC,EAAK,IAA0B,MAAZA,EAAK,GACnC,IAAI8D,EAAAxF,QAAaT,EAAKC,EAAMkC,EAAK+D,MAAM,GAAGC,cAAe3F,GACzD,IAAI4F,EAAA3F,QAAYT,EAAKC,EAAMkC,EAAM3B,GACvCuF,EAAYN,EAAUjF,EAAOZ,IAGjCK,EAAKoG,iBACLb,EAAcxF,EAAKC,EAAK4D,WAAY4B,GAG5C,OAAOA,GACRA,IA5MP,IAAAxC,EAAAC,EAAA/D,EAAA,cACA2G,EAAA5C,EAAA/D,EAAA,mBACAiH,EAAAlD,EAAA/D,EAAA,mBACA8G,EAAA/C,EAAA/D,EAAA,oBACAW,EAAAX,EAAA,kSAKA,IAAMmF,EAAY,0BACZO,EAAgB,2DAChByB,EAAqB,qBACrBC,EAAgB,0CAChBC,EAAe,kCACfC,EAAS,WACTC,GAAY,EAAA5G,EAAAoC,WASlB,SAAS0D,EAAiBe,GACtB,OAA8B,IAAvBA,EAAIC,QAAQ,MAWvB,SAASb,EAAYN,EAAUtF,EAAM0F,IACjC,EAAA/F,EAAA8E,YAAWN,EAAWnE,EAAM,SAAC2E,GACzB,IAAM6B,EAAM7B,EAAQ,GACd1D,GAAuBuF,EA2CpBtC,QAAQkC,EAAe,IAAIM,MAAML,IAAiB,IAAIb,OAAO,SAACvE,EAAQE,GAK/E,OAJAA,EAAQA,EAAMuF,MAAMJ,GAAQ,IACG,IAA3BrF,EAAOwF,QAAQtF,IACfF,EAAOmB,KAAKjB,GAETF,GACR,IAhDCyE,EAAQiB,UAAU1F,GACbkF,EAAmBS,KAAKJ,IAoBrC,SAA2BK,EAAM5F,GAC7B,KAAM4F,KAAQN,GAAY,CACtB,IAAIO,EAAI,UAAAC,OAAaF,EAAb,KACR,GAAI5F,EAAO1B,OAAQ,CACf,IAAMyH,EAAO/F,EAAOgG,IAAI,SAAC5G,GAAD,MAAA,GAAA0G,OAAc1G,EAAd,aAAA0G,OAA+B1G,EAA/B,QACxByG,EAAI,OAAAC,OAAUC,EAAKE,KAAK,KAApB,MAAAH,OAA6BD,GAGrCP,EAAUM,GAAQ,IAAIM,SAASL,IA3B3BM,CAAkBZ,EAAKvF,GAE3BA,EAAO2B,QAAQ,SAACzB,GACNA,KAASmE,IACXA,EAASnE,GAAS,IAEtBmE,EAASnE,GAAOiB,KAAKsD,OAmDjC,SAASrB,EAAclD,EAAOR,GAC1B,OAAQQ,KAASoF,EAAaA,EAAUpF,GAAO7B,KAAKqB,GAAQA,EAAKQ,6LCpGrE,MAAAkG,KAAArI,EAAA,gDACAU,EAAAV,EAAA,YACAW,EAAAX,EAAA,oLAQqBsI,aAUjB,SAAAA,EAAYzH,EAAKc,gGAAMT,CAAA3B,KAAA+I,GACnB/I,KAAKgJ,IAAK,EAAA5H,EAAA6H,OACV,IAAM5D,GAAO,EAAAjE,EAAAqF,WAAUnF,GACvBtB,KAAKuF,KAAOvF,KAAKqF,MAAO,EAAAjE,EAAA8H,cAAa7D,EAAMrF,KAAKgJ,IAChDhJ,KAAK+G,UAAW,EAAA5F,EAAA2F,eAAc9G,KAAMqF,EAAKF,YACzCnF,KAAKuC,OAAS,IAAIuG,EAAA/G,QAClB/B,KAAKoC,MAAO,EAAAhB,EAAAoC,WACZxD,KAAKmJ,SAAU,EACX/G,GACApC,KAAKoJ,IAAIhH,wDAYXmD,GAQF,OAPIvF,KAAKqJ,aACLrJ,KAAK2E,UAETY,EAAKG,YAAY1F,KAAKqF,MACtBrF,KAAKuF,KAAOA,EACZvF,KAAKmJ,SAAU,EACfnJ,KAAKuC,OAAOC,KAAK,QAAS+C,GACnBvF,uCAUD,IAAA0B,EAAA1B,KASN,OARIA,KAAKqJ,eACL,EAAAjI,EAAAkI,kBAAiBtJ,KAAKuJ,UAAWvJ,KAAKgJ,IAAI3E,QAAQ,SAAC9C,GAC/CG,EAAK2D,KAAKK,YAAYnE,KAE1BvB,KAAKuF,KAAOvF,KAAKqF,KACjBrF,KAAKmJ,SAAU,EACfnJ,KAAKuC,OAAOC,KAAK,YAEdxC,iCAWP4C,GACA,OAAOA,KAAS5C,KAAKoC,KAAOpC,KAAKoC,KAAKQ,GAAS,iCAY/CA,EAAOd,GAAO,IAAA0H,EAAAxJ,KACd,GAAqB,iBAAV4C,EAAX,CAKA,GADA5C,KAAKoC,KAAKQ,GAASd,EACfc,KAAS5C,KAAK+G,SAAU,CACxB,IAAM0C,EAASzD,SAAS0D,SAAS1J,KAAKuJ,WAAa,SAAW,SAC9DvJ,KAAK+G,SAASnE,GAAOyB,QAAQ,SAAC8C,GACtBA,EAAQwC,gBACRxC,EAAQsC,OAIpB,OAAOzJ,KAZH4J,OAAOC,KAAKjH,GAAOyB,QAAQ,SAACZ,GAAD,OAAU+F,EAAKJ,IAAI3F,EAAMb,EAAMa,iCAyB/DA,EAAMC,GAAU,IAAAoG,EAAA9J,KAEf,OADAA,KAAKuC,OAAOwH,GAAGtG,EAAMC,GACd,WAAA,OAAMoG,EAAKvH,OAAOyH,OAAOvG,EAAMC,kCAYpCuG,GACF,OAAO9F,MAAM6C,KAAKhH,KAAKuJ,UAAUW,iBAAiBD,sCAWlD,OAAOjK,KAAKuF,yCAWZ,OAAOvF,KAAKmJ,wNCrGb,WACH,OAAOS,OAAOO,OAAO,oBAYlB,SAAoBC,EAAInC,EAAKlC,GAChC,IAAIK,EACAgE,EAAGtK,SACHsK,EAAGC,UAAY,GAEnB,KAAQjE,EAAUgE,EAAGE,KAAKrC,IACtBlC,EAAGK,iBAWJ,SAAoBmE,GACvB,MAAiC,sBAA1B,GAAGC,SAASzJ,KAAKwJ,aAWrB,SAAgBtC,GACnB,OAAOwC,EAAOpC,KAAKJ,iBAUhB,SAAoBA,GACvB,OAAW,MAAPA,EAGe,iBAARA,EAGJA,EAFIA,EAAItC,QAAQ+E,EAAc,SAAClK,GAAD,OAAOmK,EAAcnK,IAAM,KAHrD,gBAgBR,SAAmBoK,GACtB,GAAIC,EAAkB,CAClB,IAAMC,EAAW9E,SAAS+E,cAAc,YAExC,OADAD,EAASE,UAAYJ,EACd5E,SAASiF,WAAWH,EAASI,SAAS,GAEjD,IAAM7F,EAAOW,SAASC,yBAChBkF,EAAMnF,SAAS+E,cAAc,OACnCI,EAAIH,UAAYJ,EAChB,KAAOO,EAAIC,YACP/F,EAAKK,YAAYyF,EAAIC,YAEzB,OAAO/F,SASJ,WACH,OAAOgG,KAAKC,MAAoC,OAA7BC,IAAYF,KAAKG,WAAqBhB,SAAS,IAAIiB,UAAU,mBAY7E,SAAsB7G,EAAQrD,GACjC,GAAIA,aAAgBgD,EAAAxC,QAAS,CACzB,IAAIiD,EAAQ,EACN1D,EAAMC,EAEZ,IADAA,EAAOqD,EAAOwG,WACP7J,GAAM,CACT,GAAIA,EAAKtB,UAAYqB,EAAI0H,GACrB,OAAOhE,EAEXzD,EAAOA,EAAKmK,YACZ1G,IAEJ,OAAO,EAEX,OAAOkD,EAAQnH,KAAK6D,EAAOO,WAAY5D,gBAWpC,SAAmBA,GACtB,GAAIA,aAAgBgD,EAAAxC,QAChB,OAAOR,EAAKgI,UAEhB,OAAOhI,EAAKsD,2BAaT,SAAsBQ,EAAM2D,GAC/B,IAAM2C,EAAQ3F,SAASU,eAAe,IAChCkF,EAAO5F,SAASU,eAAe,IAIrC,OAHAiF,EAAM1L,QAAU2L,EAAK3L,QAAU+I,EAC/B3D,EAAKI,aAAakG,EAAOtG,EAAK+F,YAC9B/F,EAAKK,YAAYkG,GACVvG,sBAaJ,SAA0BE,EAAMyD,GACnC,IAAM6C,EAAW,GACbtK,EAAOgE,EAAK6F,WAAYU,GAAQ,EACpC,KAAOvK,GACCA,EAAKtB,UAAY+I,GAAO8C,EAEjBvK,EAAKtB,UAAY+I,GAAM8C,IAC9BA,GAAQ,EACRD,EAAShI,KAAKtC,IAHduK,GAAQ,EAKRA,GACAD,EAAShI,KAAKtC,GAElBA,EAAOA,EAAKmK,YAEhB,OAAOG,qBAYJ,SAAyBtK,EAAMkC,EAAM3B,GAExC,OA1NYA,EAyNGA,EAAfA,EAxNc,SAAVA,GAGU,UAAVA,IAGU,SAAVA,EAGU,cAAVA,EAGGA,OAFH,EAHO,MAkNH2B,GACJ,IAAK,QACDlC,EAAKwK,UAAYjK,EACjB,MACJ,IAAK,QACDP,EAAKyK,MAAMC,QAAUnK,EACrB,MACJ,IAAK,QACD,IAAMoK,EAAM3K,EAAK4K,QAAQ1E,cACzB,GAAY,UAARyE,GAA2B,aAARA,EAAoB,CACvC3K,EAAKO,MAAQA,EACb,MAGR,QACQ2B,KAAQlC,EACRA,EAAKkC,GAAiB,MAAT3B,EAAgB,GAAKA,EAClB,MAATA,IAA2B,IAAVA,GACxBP,EAAK6K,aAAa3I,EAAM3B,GAEf,MAATA,IAA2B,IAAVA,GACjBP,EAAK4B,gBAAgBM,GA/OrC,IAAgB3B,oBA2PT,SAAwB4B,GACtB2I,IACDA,EAAQC,sBAAsBxJ,IAElCyJ,EAAM1I,KAAKH,IA/Rf,MAKI2I,EALJ9H,KAAA9D,EAAA,0CAMA,IAAI8K,EAAU,EACRgB,EAAQ,GACRrE,EAAU,GAAGA,QACbuC,EAAS,iBACTC,EAAe,WACfC,EAAgB,CAClB6B,IAAK,OACLC,IAAK,OACLC,IAAK,QACLC,IAAK,QACLC,IAAM,UAMJ/B,EAAmB,YAAa7E,SAAS+E,cAAc,YAiR7D,SAASjI,IAEL,IADAuJ,EAAQ,KACDE,EAAMvL,QAAQuL,EAAMM,KAANN,8BT5SzB","file":"templar.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\r\n * Import dependencies\r\n */\r\nimport Binding from './binding';\r\nimport { interpolate } from './parser';\r\nimport { updateAttribute } from './util';\r\n\r\n/**\r\n * Bind a token to a DOM node attribute\r\n *\r\n * @class AttrBinding\r\n * @extends Binding\r\n * @api private\r\n */\r\nexport default class AttrBinding extends Binding {\r\n    /**\r\n     * Instantiate the class\r\n     *\r\n     * @constructor\r\n     * @param {Templar} tpl\r\n     * @param {Node} node\r\n     * @param {String} attr\r\n     * @param {String} text\r\n     * @api private\r\n     */\r\n    constructor(tpl, node, attr, text) {\r\n        super(tpl, text);\r\n        this.node = node;\r\n        this.attr = attr;\r\n        this.value = null;\r\n    }\r\n\r\n    /**\r\n     * Update the attribute of the node,\r\n     * if empty then remove the attribute\r\n     *\r\n     * @api private\r\n     */\r\n    render() {\r\n        super.render();\r\n        const oldValue = this.value;\r\n        this.value = interpolate(this.text, this.tpl.data).trim();\r\n        updateAttribute(this.node, this.attr, this.value);\r\n        this.tpl.events.emit('attributechange', this.node, oldValue, this.value);\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport { scheduleRender } from './util';\r\n\r\n/**\r\n * Abstract class that binds a token\r\n * to a DOM node\r\n *\r\n * @class Binding\r\n * @api private\r\n */\r\nexport default class Binding {\r\n    /**\r\n     * Instantiate the class\r\n     *\r\n     * @constructor\r\n     * @param {Templar} tpl\r\n     * @param {String} text\r\n     * @api private\r\n     */\r\n    constructor(tpl, text) {\r\n        this.tpl = tpl;\r\n        this.text = text;\r\n    }\r\n\r\n    /**\r\n     * Add the tokens that this binding\r\n     * makes use of\r\n     *\r\n     * @param {Array} tokens\r\n     * @api private\r\n     */\r\n    setTokens(tokens) {\r\n        this.tokens = tokens;\r\n    }\r\n\r\n\r\n    /**\r\n     * Ensure all the tokens are defined\r\n     * before rendering any changes\r\n     *\r\n     * @return {Boolean}\r\n     * @api private\r\n     */\r\n    shouldUpdate() {\r\n        return this.tokens.every((token) => token in this.tpl.data);\r\n    }\r\n\r\n    /**\r\n     * Schedule a frame to update the\r\n     * DOM node\r\n     *\r\n     * @api private\r\n     */\r\n    update() {\r\n        if (!this.renderer) {\r\n            this.renderer = this.render.bind(this);\r\n            scheduleRender(this.renderer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear `renderer` to allow\r\n     * updates\r\n     *\r\n     * @api private\r\n     */\r\n    render() {\r\n        this.renderer = null;\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport Binding from './binding';\r\nimport { isFunction } from './util';\r\n\r\n/**\r\n * Bind a token to a DOM node event handler\r\n *\r\n * @class EventBinding\r\n * @extends Binding\r\n * @api private\r\n */\r\nexport default class EventBinding extends Binding {\r\n    /**\r\n     * Instantiate the class\r\n     *\r\n     * @constructor\r\n     * @param {Templar} tpl\r\n     * @param {Node} node\r\n     * @param {String} type\r\n     * @param {String} value\r\n     * @api private\r\n     */\r\n    constructor(tpl, node, type, value) {\r\n        super(tpl, value);\r\n        this.node = node;\r\n        this.type = type;\r\n        this.node['on' + type] = null;\r\n        this.node.removeAttribute('on' + type);\r\n        this.value = null;\r\n    }\r\n\r\n    /**\r\n     * Update the event handler of the node\r\n     *\r\n     * @api private\r\n     */\r\n    render() {\r\n        super.render();\r\n        const oldValue = this.value;\r\n        const value = this.tpl.data[this.tokens[0]];\r\n        if (value === this.value) {\r\n            return;\r\n        }\r\n        if (this.value) {\r\n            this.node.removeEventListener(this.type, this.value);\r\n            this.value = null;\r\n        }\r\n        if (isFunction(value)) {\r\n            this.node.addEventListener(this.type, value);\r\n            this.value = value;\r\n            this.tpl.events.emit('attributechange', this.node, oldValue, this.value);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport { hashmap } from './util';\r\n\r\n/**\r\n * Custom event class\r\n *\r\n * @class EventEmitter\r\n * @api private\r\n */\r\nexport default class EventEmitter {\r\n    /**\r\n     * Instantiate the class\r\n     *\r\n     * @constructor\r\n     * @api public\r\n     */\r\n    constructor() {\r\n        this.events = hashmap();\r\n    }\r\n\r\n    /**\r\n     * Add a listener for a custom event\r\n     *\r\n     * @param {String} name\r\n     * @param {Function} callback\r\n     * @api public\r\n     */\r\n    on(name, callback) {\r\n        let callbacks = this.events[name];\r\n        if (callbacks === undefined) {\r\n            callbacks = [];\r\n            this.events[name] = callbacks;\r\n        }\r\n        callbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Remove a listener from a custom event\r\n     *\r\n     * @param {String} name\r\n     * @param {Function} callback\r\n     * @api public\r\n     */\r\n    remove(name, callback) {\r\n        const callbacks = this.events[name];\r\n        if (callbacks !== undefined) {\r\n            for (let i = 0, len = callbacks.length; i < len; i++) {\r\n                if (callbacks[i] === callback) {\r\n                    callbacks.splice(i, 1);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch a custom event to all its\r\n     * listeners\r\n     *\r\n     * @param {String} name\r\n     * @param {...*} args\r\n     * @api public\r\n     */\r\n    emit(name, ...args) {\r\n        const callbacks = this.events[name];\r\n        if (callbacks !== undefined && callbacks.length) {\r\n            callbacks.forEach((callback) => callback(...args));\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport Templar from './templar';\r\n\r\n/**\r\n * Factory function for creating\r\n * `Templar` instances\r\n *\r\n * @param {String} tpl\r\n * @param {Object} data (optional)\r\n * @return {Templar}\r\n * @api public\r\n */\r\nexport default function templar(tpl, data) {\r\n    return new Templar(tpl, data);\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport Templar from './templar';\r\nimport Binding from './binding';\r\nimport { interpolateDOM } from './parser';\r\nimport { getNodeIndex, getParent } from './util';\r\n\r\n/**\r\n * Bind a token to a DOM node\r\n *\r\n * @class NodeBinding\r\n * @extends Binding\r\n * @api private\r\n */\r\nexport default class NodeBinding extends Binding {\r\n    /**\r\n     * Instantiate the class\r\n     *\r\n     * @constructor\r\n     * @param {Templar} tpl\r\n     * @param {Node} node\r\n     * @api private\r\n     */\r\n    constructor(tpl, node) {\r\n        super(tpl, node.data);\r\n        this.nodes = [node];\r\n    }\r\n\r\n    /**\r\n     * Remove all the current nodes occupying\r\n     * the token placeholders\r\n     *\r\n     * @api private\r\n     */\r\n    purge() {\r\n        this.nodes.forEach((node) => {\r\n            if (node instanceof Templar) {\r\n                node.unmount();\r\n                return;\r\n            }\r\n            const parent = node.parentNode;\r\n            if (parent) {\r\n                parent.removeChild(node);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Replace the token placeholders with the\r\n     * current values in the `Templar` instance\r\n     *\r\n     * @api private\r\n     */\r\n    render() {\r\n        super.render();\r\n        const nodes = [];\r\n        const node = this.nodes[0];\r\n        const parent = getParent(node);\r\n        const index = getNodeIndex(parent, node);\r\n        const children = parent.childNodes;\r\n        this.purge();\r\n        const frag = interpolateDOM(this.text, this.tpl.data, (value) => {\r\n            if (value instanceof Templar) {\r\n                value.root = parent;\r\n            }\r\n            value.nodeType === 11 ? nodes.push.apply(nodes, value.childNodes) : nodes.push(value);\r\n        });\r\n        this.nodes = nodes;\r\n        index in children ? parent.insertBefore(frag, children[index]) : parent.appendChild(frag);\r\n        this.tpl.events.emit('change', parent);\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport Templar from './templar';\r\nimport NodeBinding from './node-binding';\r\nimport AttrBinding from './attr-binding';\r\nimport EventBinding from './event-binding';\r\nimport { hashmap, getMatches, escapeHTML, parseHTML, isHTML } from './util';\r\n\r\n/**\r\n * Common variables\r\n */\r\nconst matcherRe = /\\{\\{\\s*\\&?(.+?)\\s*\\}\\}/g;\r\nconst nodeContentRe = /\\{\\{\\s*(.+?)\\s*\\}\\}|((?:(?!(?:\\{\\{\\s*(.+?)\\s*\\}\\})).)+)/g;\r\nconst simpleIdentifierRe = /^\\&?[A-Za-z0-9_]+$/;\r\nconst expressionsRe = /\"[^\"]*\"|'[^']*'|\\/([^/]+)\\/|true|false/g;\r\nconst identifierRe = /[a-zA-Z_]\\w*([.][a-zA-Z_]\\w*)*/g;\r\nconst rootRe = /^([^.]+)/;\r\nconst exprCache = hashmap();\r\n\r\n/**\r\n * Check if a string has interpolation\r\n *\r\n * @param {String} str\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction hasInterpolation(str) {\r\n    return str.indexOf('{{') !== -1;\r\n}\r\n\r\n/**\r\n * Map tokens to a `Binding` instance\r\n *\r\n * @param {Object} bindings\r\n * @param {String} text\r\n * @param {Binding} binding\r\n * @api private\r\n */\r\nfunction addBindings(bindings, text, binding) {\r\n    getMatches(matcherRe, text, (matches) => {\r\n        const str = matches[1];\r\n        const tokens = extractTokens(str);\r\n        binding.setTokens(tokens);\r\n        if (!simpleIdentifierRe.test(str)) {\r\n            compileExpression(str, tokens);\r\n        }\r\n        tokens.forEach((token) => {\r\n            if (!(token in bindings)) {\r\n                bindings[token] = [];\r\n            }\r\n            bindings[token].push(binding);\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Convert a string expression into\r\n * a function\r\n *\r\n * @param {String} expr\r\n * @param {Array} tokens\r\n * @api private\r\n */\r\nfunction compileExpression(expr, tokens) {\r\n    if (!(expr in exprCache)) {\r\n        let body = `return ${expr};`;\r\n        if (tokens.length) {\r\n            const vars = tokens.map((value) => `${value} = this['${value}']`);\r\n            body = `var ${vars.join(',')}; ${body}`;\r\n        }\r\n        // eslint-disable-next-line no-new-func\r\n        exprCache[expr] = new Function(body);\r\n    }\r\n}\r\n\r\n/**\r\n * Extract the tokens from an expression\r\n * string\r\n *\r\n * @param {String} expr\r\n * @return {Array}\r\n * @api private\r\n */\r\nfunction extractTokens(expr) {\r\n    return (expr.replace(expressionsRe, '').match(identifierRe) || []).reduce((tokens, token) => {\r\n        token = token.match(rootRe)[1];\r\n        if (tokens.indexOf(token) === -1) {\r\n            tokens.push(token);\r\n        }\r\n        return tokens;\r\n    }, []);\r\n}\r\n\r\n/**\r\n * Get the value of a token\r\n *\r\n * @param {String} token\r\n * @param {Object} data\r\n * @return {String|Number|Boolean|Node|Templar}\r\n * @api private\r\n */\r\nfunction getTokenValue(token, data) {\r\n    return (token in exprCache) ? exprCache[token].call(data) : data[token];\r\n}\r\n\r\n/**\r\n * Supplant the tokens of a string with\r\n * the corresponding value in an object\r\n * literal\r\n *\r\n * @param {String} tpl\r\n * @param {Object} data\r\n * @return {String}\r\n * @api private\r\n */\r\nexport function interpolate(tpl, data) {\r\n    return tpl.replace(matcherRe, (all, token) => getTokenValue(token, data));\r\n}\r\n\r\n/**\r\n * Build a document fragment that supplants\r\n * the tokens of a string with the\r\n * corresponding value in an object literal\r\n *\r\n * @param {String} tpl\r\n * @param {Object} data\r\n * @param {Function} fn\r\n * @return {DocumentFragment}\r\n * @api private\r\n */\r\nexport function interpolateDOM(tpl, data, fn) {\r\n    const frag = document.createDocumentFragment();\r\n    getMatches(nodeContentRe, tpl, (matches) => {\r\n        let value;\r\n        if (matches[1] != null) {\r\n            let token = matches[1], escape = false;\r\n            if (token[0] === '&') {\r\n                escape = true;\r\n                token = token.substr(1);\r\n            }\r\n            value = getTokenValue(token, data);\r\n            switch (typeof value) {\r\n                case 'string':\r\n                    if (!escape && isHTML(value)) {\r\n                        value = parseHTML(value);\r\n                        break;\r\n                    }\r\n                    // falls through\r\n                case 'number':\r\n                case 'boolean':\r\n                    value = document.createTextNode(escapeHTML(value));\r\n                    break;\r\n                default:\r\n                    if (value instanceof Templar) {\r\n                        value.mount(frag);\r\n                    }\r\n            }\r\n        } else if (matches[2] != null) {\r\n            value = document.createTextNode(matches[2]);\r\n        }\r\n        if (value != null) {\r\n            fn(value);\r\n            if (value.nodeName) {\r\n                frag.appendChild(value);\r\n            }\r\n        }\r\n    });\r\n    return frag;\r\n}\r\n\r\n/**\r\n * Parses the nodes of a template to\r\n * create a key/value object that maps\r\n * the template tokens to a `Binding`\r\n * instance capable of supplanting the\r\n * value in the DOM\r\n *\r\n * @param {Templar} tpl\r\n * @param {NodeList} nodes\r\n * @param {String} id\r\n * @param {Object} bindings\r\n * @return {Object}\r\n * @api private\r\n */\r\nexport function parseTemplate(tpl, nodes, bindings = hashmap()) {\r\n    return Array.from(nodes).reduce((bindings, node) => {\r\n        if (node.nodeType === 3) {\r\n            if (hasInterpolation(node.data)) {\r\n                const binding = new NodeBinding(tpl, node);\r\n                addBindings(bindings, node.data, binding);\r\n            }\r\n        } else if (node.nodeType === 1) {\r\n            for (let i = 0, length = node.attributes.length; i < length; i++) {\r\n                const attr = node.attributes[i], name = attr.name, value = attr.value;\r\n                if (hasInterpolation(value)) {\r\n                    const binding = (name[0] === 'o' && name[1] === 'n')\r\n                        ? new EventBinding(tpl, node, name.slice(2).toLowerCase(), value)\r\n                        : new AttrBinding(tpl, node, name, value);\r\n                    addBindings(bindings, value, binding);\r\n                }\r\n            }\r\n            if (node.hasChildNodes()) {\r\n                parseTemplate(tpl, node.childNodes, bindings);\r\n            }\r\n        }\r\n        return bindings;\r\n    }, bindings);\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport EventEmitter from './event-emitter';\r\nimport { parseTemplate } from './parser';\r\nimport { hashmap, parseHTML, uid, wrapFragment, getTemplateNodes } from './util';\r\n\r\n/**\r\n * DOM templating class\r\n *\r\n * @class Templar\r\n * @api public\r\n */\r\nexport default class Templar {\r\n    /**\r\n     * Instantiate the class providing the\r\n     * template string\r\n     *\r\n     * @constructor\r\n     * @param {String} tpl\r\n     * @param {Object} data (optional)\r\n     * @api public\r\n     */\r\n    constructor(tpl, data) {\r\n        this.id = uid();\r\n        const frag = parseHTML(tpl);\r\n        this.root = this.frag = wrapFragment(frag, this.id);\r\n        this.bindings = parseTemplate(this, frag.childNodes);\r\n        this.events = new EventEmitter();\r\n        this.data = hashmap();\r\n        this.mounted = false;\r\n        if (data) {\r\n            this.set(data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Append the template to a parent\r\n     * element\r\n     *\r\n     * @param {Element} root\r\n     * @return {Templar}\r\n     * @api public\r\n     */\r\n    mount(root) {\r\n        if (this.isMounted()) {\r\n            this.unmount();\r\n        }\r\n        root.appendChild(this.frag);\r\n        this.root = root;\r\n        this.mounted = true;\r\n        this.events.emit('mount', root);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the template from it's\r\n     * parent element\r\n     *\r\n     * @return {Templar}\r\n     * @api public\r\n     */\r\n    unmount() {\r\n        if (this.isMounted()) {\r\n            getTemplateNodes(this.getRoot(), this.id).forEach((node) => {\r\n                this.frag.appendChild(node);\r\n            });\r\n            this.root = this.frag;\r\n            this.mounted = false;\r\n            this.events.emit('unmount');\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the value for a token in\r\n     * the template\r\n     *\r\n     * @param {String} token\r\n     * @return {String|Number|Boolean|Node|Templar|Function}\r\n     * @api public\r\n     */\r\n    get(token) {\r\n        return token in this.data ? this.data[token] : null;\r\n    }\r\n\r\n    /**\r\n     * Set the value for a token in\r\n     * the template\r\n     *\r\n     * @param {String|Object} token\r\n     * @param {String|Number|Boolean|Node|Templar|Function} value\r\n     * @return {Templar}\r\n     * @api public\r\n     */\r\n    set(token, value) {\r\n        if (typeof token !== 'string') {\r\n            Object.keys(token).forEach((name) => this.set(name, token[name]));\r\n            return;\r\n        }\r\n        this.data[token] = value;\r\n        if (token in this.bindings) {\r\n            const method = document.contains(this.getRoot()) ? 'update' : 'render';\r\n            this.bindings[token].forEach((binding) => {\r\n                if (binding.shouldUpdate()) {\r\n                    binding[method]();\r\n                }\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a listener for a custom event.\r\n     * Returns a function that removes the\r\n     * listener when invoked\r\n     *\r\n     * @param {String} name\r\n     * @param {Function} callback\r\n     * @return {Function}\r\n     * @api public\r\n     */\r\n    on(name, callback) {\r\n        this.events.on(name, callback);\r\n        return () => this.events.remove(name, callback);\r\n    }\r\n\r\n    /**\r\n     * Query the template for all the\r\n     * elements matching the provided\r\n     * selector string\r\n     *\r\n     * @param {String} selector\r\n     * @return {Array}\r\n     * @api public\r\n     */\r\n    query(selector) {\r\n        return Array.from(this.getRoot().querySelectorAll(selector));\r\n    }\r\n\r\n    /**\r\n     * Get the root element of the\r\n     * template\r\n     *\r\n     * @return {Element}\r\n     * @api public\r\n     */\r\n    getRoot() {\r\n        return this.root;\r\n    }\r\n\r\n    /**\r\n     * Is the template mounted to\r\n     * a parent element?\r\n     *\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n    isMounted() {\r\n        return this.mounted;\r\n    }\r\n}\r\n","/**\r\n * Import dependencies\r\n */\r\nimport Templar from './templar';\r\n\r\n/**\r\n * Common variables\r\n */\r\nlet frame;\r\nlet counter = 1;\r\nconst batch = [];\r\nconst indexOf = [].indexOf;\r\nconst htmlRe = /<[a-z][\\s\\S]*>/;\r\nconst escapeHTMLRe = /[<>&\"']/g;\r\nconst escapeHTMLMap = {\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '&': '&amp;',\r\n    '\"': '&#39;',\r\n    '\\'': '&quot;'\r\n};\r\n\r\n/**\r\n * Check if the browser supports the <template> element\r\n */\r\nconst supportsTemplate = 'content' in document.createElement('template');\r\n\r\n/**\r\n * Convert strings of primitives\r\n * into their natural type\r\n *\r\n * @param {String} value\r\n * @return {String|Boolean|Null|Undefined}\r\n * @api private\r\n */\r\nfunction coerce(value) {\r\n    if (value === 'true') {\r\n        return true;\r\n    }\r\n    if (value === 'false') {\r\n        return false;\r\n    }\r\n    if (value === 'null') {\r\n        return null;\r\n    }\r\n    if (value === 'undefined') {\r\n        return void 0;\r\n    }\r\n    return value;\r\n}\r\n\r\n/**\r\n * Get a 'bare' object for basic\r\n * key/value hash maps\r\n *\r\n * @return {Object}\r\n * @api private\r\n */\r\nexport function hashmap() {\r\n    return Object.create(null);\r\n}\r\n\r\n/**\r\n * Iterates through all the matches\r\n * of the provided regex and string\r\n *\r\n * @param {RegExp} re\r\n * @param {String} str\r\n * @param {Function} fn\r\n * @api private\r\n */\r\nexport function getMatches(re, str, fn) {\r\n    let matches;\r\n    if (re.global) {\r\n        re.lastIndex = 0;\r\n    }\r\n    while ((matches = re.exec(str))) {\r\n        fn(matches);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if an object is a function\r\n *\r\n * @param {*} obj\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nexport function isFunction(obj) {\r\n    return {}.toString.call(obj) === '[object Function]';\r\n}\r\n\r\n/**\r\n * Is the provided string an HTML\r\n * string?\r\n *\r\n * @param {String} str\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nexport function isHTML(str) {\r\n    return htmlRe.test(str);\r\n}\r\n\r\n/**\r\n * Escape HTML characters\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\nexport function escapeHTML(str) {\r\n    if (str == null) {\r\n        return '';\r\n    }\r\n    if (typeof str === 'string') {\r\n        return str.replace(escapeHTMLRe, (c) => escapeHTMLMap[c] || '');\r\n    }\r\n    return str;\r\n}\r\n\r\n/**\r\n * Convert an HTML string into a\r\n * document fragment\r\n *\r\n * @param {String} html\r\n * @return {DocumentFragment}\r\n * @api private\r\n */\r\nexport function parseHTML(html) {\r\n    if (supportsTemplate) {\r\n        const template = document.createElement('template');\r\n        template.innerHTML = html;\r\n        return document.importNode(template.content, true);\r\n    }\r\n    const frag = document.createDocumentFragment();\r\n    const div = document.createElement('div');\r\n    div.innerHTML = html;\r\n    while (div.firstChild) {\r\n        frag.appendChild(div.firstChild);\r\n    }\r\n    return frag;\r\n}\r\n\r\n/**\r\n * Generate a unique id\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\nexport function uid() {\r\n    return Math.floor((counter++ + Math.random()) * 0x10000).toString(16).substring(1);\r\n}\r\n\r\n/**\r\n * Get the index of a node or template\r\n * amongst its sibling nodes\r\n *\r\n * @param {Node} parent\r\n * @param {Node|Templar} node\r\n * @return {Number}\r\n * @api private\r\n */\r\nexport function getNodeIndex(parent, node) {\r\n    if (node instanceof Templar) {\r\n        let index = 0;\r\n        const tpl = node;\r\n        node = parent.firstChild;\r\n        while (node) {\r\n            if (node.templar === tpl.id) {\r\n                return index;\r\n            }\r\n            node = node.nextSibling;\r\n            index++;\r\n        }\r\n        return 0;\r\n    }\r\n    return indexOf.call(parent.childNodes, node);\r\n}\r\n\r\n/**\r\n * Get the parent element of a node or\r\n * template\r\n *\r\n * @param {Node|Templar} node\r\n * @return {Element}\r\n * @api private\r\n */\r\nexport function getParent(node) {\r\n    if (node instanceof Templar) {\r\n        return node.getRoot();\r\n    }\r\n    return node.parentNode;\r\n}\r\n\r\n/**\r\n * Wrap a document fragment in empty text\r\n * nodes so that the beginning and end of a\r\n * template is easily identifiable in the DOM\r\n *\r\n * @param {DocumentFragment} frag\r\n * @param {String} id\r\n * @return {DocumentFragment}\r\n * @api private\r\n */\r\nexport function wrapFragment(frag, id) {\r\n    const first = document.createTextNode('');\r\n    const last = document.createTextNode('');\r\n    first.templar = last.templar = id;\r\n    frag.insertBefore(first, frag.firstChild);\r\n    frag.appendChild(last);\r\n    return frag;\r\n}\r\n\r\n/**\r\n * Find the template elements within the\r\n * provided root element that match the\r\n * provided template ID\r\n *\r\n * @param {Element} root\r\n * @param {String} id\r\n * @return {Array}\r\n * @api private\r\n */\r\nexport function getTemplateNodes(root, id) {\r\n    const elements = [];\r\n    let node = root.firstChild, isTpl = false;\r\n    while (node) {\r\n        if (node.templar === id && !isTpl) {\r\n            isTpl = true;\r\n        } else if (node.templar === id && isTpl) {\r\n            isTpl = false;\r\n            elements.push(node);\r\n        }\r\n        if (isTpl) {\r\n            elements.push(node);\r\n        }\r\n        node = node.nextSibling;\r\n    }\r\n    return elements;\r\n}\r\n\r\n/**\r\n * Set the attribute/property of a DOM\r\n * node\r\n *\r\n * @param {Element} node\r\n * @param {String} name\r\n * @param {String} value\r\n * @api private\r\n */\r\nexport function updateAttribute(node, name, value) {\r\n    value = coerce(value);\r\n    switch (name) {\r\n        case 'class':\r\n            node.className = value;\r\n            break;\r\n        case 'style':\r\n            node.style.cssText = value;\r\n            break;\r\n        case 'value':\r\n            const tag = node.tagName.toLowerCase();\r\n            if (tag === 'input' || tag === 'textarea') {\r\n                node.value = value;\r\n                break;\r\n            }\r\n            // falls through\r\n        default:\r\n            if (name in node) {\r\n                node[name] = value == null ? '' : value;\r\n            } else if (value != null && value !== false) {\r\n                node.setAttribute(name, value);\r\n            }\r\n            if (value == null || value === false) {\r\n                node.removeAttribute(name);\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n * Schedule a frame to render DOM\r\n * updates\r\n *\r\n * @param {Function} callback\r\n * @api private\r\n */\r\nexport function scheduleRender(callback) {\r\n    if (!frame) {\r\n        frame = requestAnimationFrame(render);\r\n    }\r\n    batch.push(callback);\r\n}\r\n\r\n/**\r\n * Render all the updates\r\n *\r\n * @api private\r\n */\r\nfunction render() {\r\n    frame = null;\r\n    while (batch.length) batch.pop()();\r\n}\r\n"]}